@doc raw"""
    HEOMsolve(M, ρ0, Δt, steps; e_ops, threshold, nonzero_tol, progress_bar)
    heomsolve(M, ρ0, Δt, steps; e_ops, threshold, nonzero_tol, progress_bar)

Solve the time evolution for auxiliary density operators based on propagator (generated by `FastExpm.jl`).

# Parameters
- `M::AbstractHEOMLSMatrix` : the matrix given from HEOM model
- `ρ0::Union{QuantumObject,ADOs}` : system initial state (density matrix) or initial auxiliary density operators (`ADOs`)
- `Δt::Real` : A specific time step (time interval).
- `steps::Int` : The number of time steps
- `e_ops::Union{Nothing,AbstractVector}`: List of operators for which to calculate expectation values.
- `threshold::Real` : Determines the threshold for the Taylor series. Defaults to `1.0e-6`.
- `nonzero_tol::Real` : Strips elements smaller than `nonzero_tol` at each computation step to preserve sparsity. Defaults to `1.0e-14`.
- `progress_bar::Union{Val,Bool}`: Whether to show the progress bar. Defaults to `Val(true)`.

# Notes
- The [`ADOs`](@ref) will be saved depend on the keyword argument `e_ops`.
- If `e_ops` is specified, the solution will only save the final `ADOs`, otherwise, it will save all the `ADOs` corresponding to `tlist = 0:Δt:(Δt * steps)`.
- For more details of the propagator, please refer to [`FastExpm.jl`](https://github.com/fmentink/FastExpm.jl)

# Returns
- `sol::TimeEvolutionHEOMSol` : The solution of the hierarchical EOM. See also [`TimeEvolutionHEOMSol`](@ref)

!!! note
    `heomsolve` is a synonym of `HEOMsolve`.
"""
function HEOMsolve(
    M::AbstractHEOMLSMatrix,
    ρ0::T_state,
    Δt::Real,
    steps::Int;
    e_ops::Union{Nothing,AbstractVector} = nothing,
    threshold = 1.0e-6,
    nonzero_tol = 1.0e-14,
    progress_bar::Union{Val,Bool} = Val(true),
) where {T_state<:Union{QuantumObject,ADOs}}

    # handle initial state
    ados = (T_state <: QuantumObject) ? ADOs(ρ0, M.N, M.parity) : ρ0
    _check_sys_dim_and_ADOs_num(M, ados)
    _check_parity(M, ados)
    ρvec = _HandleVectorType(M, ados.data)

    if e_ops isa Nothing
        expvals = Array{ComplexF64}(undef, 0, steps + 1)
        is_empty_e_ops = true
    else
        expvals = Array{ComplexF64}(undef, length(e_ops), steps + 1)
        tr_e_ops = _generate_Eops(M, e_ops)
        is_empty_e_ops = isempty(e_ops)
    end

    t_end = Δt*steps
    if is_empty_e_ops
        times = times_ados = collect(0:Δt:t_end)
        ADOs_list = Vector{ADOs}(undef, steps + 1)
    else
        times = collect(0:Δt:t_end)
        times_ados = [t_end]
        ADOs_list = Vector{ADOs}(undef, 1)
    end

    # Generate propagator
    getVal(progress_bar) && print("Generating propagator...")
    exp_Mt = Propagator(M, Δt; threshold = threshold, nonzero_tol = nonzero_tol)
    getVal(progress_bar) && println("[DONE]")

    # start solving
    progr = Progress(
        steps + 1;
        enabled = getVal(progress_bar),
        desc = "[HEOMsolve (propagator)] ",
        QuantumToolbox.settings.ProgressMeterKWARGS...,
    )
    for n in 0:steps
        # calculate expectation values
        if !is_empty_e_ops
            _expect = op -> dot(op, ρvec)
            @. expvals[:, n+1] = _expect(tr_e_ops)
            n == steps ? ADOs_list[1] = ADOs(ρvec, M.dimensions, M.N, M.parity) : nothing
        else
            ADOs_list[n+1] = ADOs(ρvec, M.dimensions, M.N, M.parity)
        end

        ρvec = exp_Mt * ρvec

        getVal(progress_bar) && next!(progr)
    end

    return TimeEvolutionHEOMSol(
        _getBtier(M),
        _getFtier(M),
        times,
        times_ados,
        ADOs_list,
        expvals,
        nothing,
        nothing,
        nothing,
        nothing,
    )
end